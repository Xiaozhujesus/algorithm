package priv.wz.array;

/**
 * 给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。
 * 假设只有一个重复的整数，找出这个重复的数
 * 说明：
 * 不能更改原数组（假设数组是只读的）。
 * 只能使用额外的 O(1) 的空间。
 * 时间复杂度小于 O(n2) 。
 * 数组中只有一个重复的数字，但它可能不止重复出现一次。
 */
public class FindDuplicate {
    public int findDuplicate(int[] arr) {
        int slow = 0;
        int fast = 0;
        do {
            slow = arr[slow];
            fast = arr[arr[fast]];
        } while (slow != fast);
        slow = 0;
        while (slow != fast) {
            slow = arr[slow];
            fast = arr[fast];
        }
        return slow;
    }
}

/**
 * 如果数组中没有重复的数，以数组 [1,3,4,2]为例，我们从下标为 0 出发得到一个list，这个就是链表的数组形式，得到0->1->3->2->4->null
 * 如果数组中有重复的数，以数组 [1,3,4,2,2] 为例，得到0->1->3->2->4->2->4->2->...
 * 链表的数组形式中，数组内的数字相当于链表的指针，那么重复的元素，相当于指向链表中相同的节点，这个节点就是链表中多个环的共同入口
 * 综上
 * 1.数组中有一个重复的整数 <==> 链表中存在环
 * 2.找到数组中的重复整数 <==> 找到链表的环入口
 */