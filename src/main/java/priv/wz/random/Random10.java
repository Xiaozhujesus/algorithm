package priv.wz.random;

/**
 * 给定方法rand7可生成 [1,7] 范围内的均匀随机整数，试写一个方法rand10生成 [1,10] 范围内的均匀随机整数。
 * <p>
 * 你只能调用rand7()且不能调用其他方法。请不要使用系统的Math.random()方法。
 */
public class Random10 extends Random7 {

    public int random10() {
        int num = (random7() - 1) * 7 + random7();
        // 只要它还大于10，那就给我不断生成，因为我只要范围在1-10的，最后直接返回就可以了
        while (num > 10) {
            num = (random7() - 1) * 7 + random7();
        }
        return num;
    }

    public int random10f() {
        int num = (random7() - 1) * 7 + random7();
        while (num > 40) {
            num = (random7() - 1) * 7 + random7();
        }
        return (num - 1) / 4 + 1;
    }
}


/**
 * 如果题目是给你 random10()让你生成1～7 之间的某个数，那非常好办，我们只要不断调用
 * random10() 即可，直到得到1-7之间的数，因为random10()生成的所有 1-10 之间的数等概率，因此 1-7 之间的数也是等概率
 * 现在要从rand7() 到rand10()，也要求是等概率的，那只要我们把小的数映射到一个大的数就好办了
 * 但是不能简单的 rand7() + rand7()，因为这种情况某些数字不是等概率，比如 5=1+4，5=2+3，5=4+1 等等
 * 为了防止这种情况，我们这样做： (rand7()−1)∗7+rand7()，其中 (rand7()−1)∗7 得到{0，7，14，21，28，35，42}，每个数字间隔 7
 * 这样加 rand7() 就不会重复了，因此等概率生成 1~49，此时用上面的思路就可以了
 * <p>
 * 还可以优化，而我们只想得到1～10 之间的数，这一部分占的比例太少了，简而言之，这样效率太低，太慢，
 * 可能要while 循环很多次，那么解决思路就是舍弃一部分数，舍弃
 * 41～49，因为是独立事件，我们生成的1～40 之间的数它是等概率的，我们最后完全可以利用1～40 之间的数来得到1～10 之间的数
 */
class Random7 {
    // 假设该函数返回 1-7 直接的随机数
    public int random7() {
        return 0;
    }
}