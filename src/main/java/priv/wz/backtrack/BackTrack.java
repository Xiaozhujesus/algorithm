package priv.wz.backtrack;

/**
 * 回溯本质上是搜素，尝试所有可能情况。编码时，程序需要具有可以回退的结构，通常是函数的递归调用，每次递归只处理一步
 * 函数栈天然记录了之前的状态，函数出栈就相当于回退一步。通常是按照某种顺序搜素，因为有了顺序就可以回退。
 * 可以参考 MColor 问题。有些问题有额外约束，因此在搜素过程中不合法的情况可能导致提前回退。
 *
 * 1. 递归处理，每轮递归基于当前状态进入下一个状态，有可能有 for 循环，为了尝试各种情况。
 * 2. 进入递归函数时，首先判断当前状态是否合法；合法则更新状态，然后判断是否结束递归，结束则记录结果，否则进行下一轮递归；不合法直接返回
 *
 * 如果要找出一种结果即可，在递归函数添加一个 boolean 返回值，然后在每一轮迭代时候如果返回 true，直接返回 true，不用继续迭代
 * 可以参考 FindSubsetSumK 的代码
 *
 * 几乎所有问题都是有条件的搜索问题，只是问题基于的数据结构和条件不同而已，比如问题是数组相关、图相关或其他结构
 */
public class BackTrack {
}
